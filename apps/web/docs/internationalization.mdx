---
title: 多言語対応
createdAt: 2025-11-20
sponsors: true
---

既存のライブラリは重く、Cache との相性も悪いためスクラッチします。

## 多言語対応の仕組み

1. 翻訳文と型を定義
2. ブラウザからユーザーの言語を取得（初回のみ）
3. 言語パスにリダイレクト(/ja, /en)
4. URLに基づいて表示言語を切り替え
5. 言語変更時はブラウザの Cookie に保存し、以降はCookieの値を使用

URLの言語階層('/ja', '/en')は [Proxy](https://nextjs.org/docs/app/getting-started/proxy) や [ライブラリ](https://next-intl.dev/) を使うことで隠蔽できます。このガイドでは隠蔽する方法を紹介します。

### 関連ファイル

最終的に以下のファイルで構成されます。

<Tree>
/lib/i18n/routing.ts # 言語パスに基づいてリダイレクトする関数
/lib/i18n/locale.ts # 言語の定義
/lib/i18n/server.ts # サーバーサイドでの言語取得とキャッシュ
/lib/i18n/utils.ts # 言語取得用のヘルパー関数
/components/i18n-provider.tsx # クライアントでの言語取得用プロバイダー
/components/locale-toggle.tsx # 表示言語の切り替えコンポーネント
/messages/ja.ts # 日本語の翻訳文
/messages/en.ts # 英語の翻訳文
/types/message.ts # 翻訳文の型定義
</Tree>

## 翻訳文の定義

まずデフォルト言語の翻訳文を定義します。

```tsx title=messages/ja.ts
export default {
  TopPage: {
    title: "トップページ",
  },
};
```

次に、デフォルト言語をベースに言語の型を定義します。

```tsx title=types/message.ts
import jaMessages from "@/messages/ja";

// 再帰的なキーパスの型を生成するヘルパー型
type NestedKeyOf<T> = T extends object
  ? {
      [K in keyof T]: K extends string
        ? T[K] extends object
          ? `${K}.${NestedKeyOf<T[K]>}` | K
          : K
        : never;
    }[keyof T]
  : never;

// ネストされたキーから値を取得する型
type NestedValueOf<T, K extends string> = K extends `${infer P}.${infer S}`
  ? P extends keyof T
    ? NestedValueOf<T[P], S>
    : never
  : K extends keyof T
    ? T[K]
    : never;

// 日本語メッセージから型を抽出
export type MessagesSchema = typeof jaMessages;
export type KeyOfMessages = keyof MessagesSchema;
export type NestedKeyOfMessages = NestedKeyOf<MessagesSchema>;
export type NestedValueOfMessages<K extends NestedKeyOfMessages> =
  NestedValueOf<MessagesSchema, K>;
```

型を使用してその他の言語の翻訳文を定義します。型安全でメッセージを定義できます。

```tsx title=messages/en.ts
import { MessagesSchema } from "@/types/message";

export default {
  TopPage: {
    title: "Top Page",
  },
} satisfies MessagesSchema;
```

以後、あらゆるテキストは翻訳文に定義したキーを使用して取得します。


## 言語の取得とリダイレクト

Proxy 用のルーティングヘルパーを作成します。このヘルパーはリダイレクトとパスの言語階層を隠蔽します。

```sh
pnpm add @formatjs/intl-localematcher
```

:::code-group

```ts title=lib/i18n/routing.ts file=../lib/i18n/routing.ts
```

```ts title=lib/i18n/locale.ts file=../lib/i18n/locale.ts
```

:::

Proxy のミドルウェアでこの関数を呼び出します。

```ts title=proxy.ts
import { handleLocaleRouting } from "@/lib/i18n/routing";

export async function proxy(request: NextRequest) {
  return handleLocaleRouting(request);
}
```

これにより、Cookie、もしくはブラウザの言語設定に応じて適切な言語パスにリダイレクトします。

## 翻訳テキストの使用

翻訳テキストを取得するためのヘルパー関数を作成します。

:::code-group

```ts title=lib/i18n/server.ts file=../lib/i18n/server.ts
```

```ts title=lib/i18n/utils.ts file=../lib/i18n/utils.ts
```

:::


## レイアウト、画面で言語を取得し、キャッシュする

まず、すべての画面やレイアウトは `/[locale]` パス配下に配置します。

### ルートレイアウト

ルートレイアウトは必要なので空で用意します、

```tsx title=app/layout.tsx
export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}
```

### メインレイアウト

これが実質的なルートレイアウトになります。動的パラメーターを使用して言語を取得し、設定します。内部的に React Cache を使用するため、サーバーサイドでのレンダリング中に下位コンポーネントはキャッシュされた言語情報にアクセスできます。

```tsx title=app/[locale]/layout.tsx
import { Providers } from "@/components/providers";
import { Locale, locales } from "@/lib/i18n/locale";
import { setCurrentLocaleFromParams } from "@/lib/i18n/server";
import "@workspace/ui/globals.css";

export async function generateStaticParams() { // [!code highlight]
  return locales.map((locale) => ({ locale })); // [!code highlight]
} // [!code highlight]

export default async function RootLayout({
  params,
  children,
}: LayoutProps<"/[locale]">) {
  const locale =await setCurrentLocaleFromParams(params); // [!code highlight]

  return (
    <html lang={locale}>
      <body>
        {children}
      </body>
    </html>
  );
}
```

### 各画面

各画面も同様に動的パラメーターを使用して言語を取得し、設定します。Next.js では Layout と Page が並列で処理されるため、Page の方が先に処理されるケースに備えて Page 側でも言語情報をキャッシュする必要があります。

- `getMessage` により既存の言語に応じた翻訳テキストを取得できます。
- `generateMetadata` を使ってメタデータを生成します。
- `generateStaticParams` を使って静的パラメーターを生成します。

```tsx title=app/[locale]/page.tsx
import { setCurrentLocaleFromParams } from "@/lib/i18n/server";
import { getMessage } from "@/lib/i18n/server";
import { locales } from "@/lib/i18n/locale";

export const generateMetadata = async ({ params }: PageProps<"/[locale]">) => {
  await setCurrentLocaleFromParams(params);
  const t = await getMessage("TopPage");
  return {
    title: t.title,
  };
};

export async function generateStaticParams() {
  return locales.map((locale) => ({ locale }));
}

export default async function Page({
  params,
}: PageProps<"/[locale]">) {
  const locale = await setCurrentLocaleFromParams(params);
  const t = await getMessage("TopPage");

  return (
    <div>
      <h1>{t.title}</h1>
    </div>
  );
}
```

## クライアント用プロバイダーの作成

クライアントで翻訳メッセージを使用するためのプロバイダーを作成します。

:::code-group

```tsx title=components/i18n-provider.tsx file=../components/i18n-provider.tsx
```

:::

次にメインレイアウトにプロバイダーを設置します。

```tsx title=app/[locale]/(main)/layout.tsx
import { I18nProvider } from "@/components/i18n-provider";

<html lang={locale}>
  <body>
    <I18nProvider locale={locale}>{children}</I18nProvider>
  </body>
</html>
```

これによりクライアントコンポーネントから翻訳テキストを取得できます。

```tsx title=components/my-component.tsx
"use client";

import { useMessage } from "@/components/i18n-provider";

export function MyComponent() {
  const t = useMessage("TopPage");
  return <div>{t.title}</div>;
}
```

## 表示言語の切り替え

切り替えコンポーネントを作成し、任意の場所で使用します。

```tsx title=components/locale-toggle.tsx
"use client";

import { Locale, locales } from "@/lib/i18n/locale";
import { Button } from "@workspace/ui/components/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@workspace/ui/components/dropdown-menu";
import { Languages } from "lucide-react";
import { usePathname } from "next/navigation";
import { useMessage, useI18n } from "./i18n-provider";

export default function LocaleToggle() {
  const pathname = usePathname();
  const { locale } = useI18n();
  const t = useMessage("Language");

  const handleChange = (nextLocale: Locale) => {
    location.href = `/${nextLocale}${pathname}`;
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <Languages />
          <span className="sr-only">{locale === "ja" ? t.ja : t.en}</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuRadioGroup
          value={locale}
          onValueChange={(value) => handleChange(value as Locale)}
        >
          {locales.map((locale) => (
            <DropdownMenuRadioItem key={locale} value={locale}>
              {t[locale]}
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```