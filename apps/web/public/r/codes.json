{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "codes",
  "type": "registry:block",
  "title": "Codes",
  "description": "シンタックスハイライトとタブ切り替え機能を備えた高機能なコードブロックコンポーネント。",
  "dependencies": [
    "@radix-ui/react-tabs"
  ],
  "registryDependencies": [
    "button",
    "select"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/codes/codes.tsx",
      "content": "\"use client\";\n\nimport {\n  SiBun,\n  SiCss,\n  SiHtml5,\n  SiJavascript,\n  SiTypescript,\n  SiYaml,\n  SiNpm,\n  SiYarn,\n  SiPnpm,\n} from \"@icons-pack/react-simple-icons\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@radix-ui/react-tabs\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { Button } from \"@workspace/ui/components/button\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@workspace/ui/components/select\";\nimport { cn } from \"@workspace/ui/lib/utils\";\nimport { Check, Copy, Terminal } from \"lucide-react\";\nimport * as React from \"react\";\nimport {\n  createContext,\n  Dispatch,\n  ReactNode,\n  use,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\n\n// Icons mapping\nconst icons = {\n  ts: SiTypescript,\n  tsx: SiTypescript,\n  js: SiJavascript,\n  jsx: SiJavascript,\n  css: SiCss,\n  html: SiHtml5,\n  yml: SiYaml,\n  sh: Terminal,\n  npm: SiNpm,\n  yarn: SiYarn,\n  bun: SiBun,\n  pnpm: SiPnpm,\n} as const;\n\n// Variants\nconst codeTriggerVariants = cva(\n  \"flex items-center gap-2 text-sm rounded px-2 py-1 outline-none transition-colors text-nowrap truncate max-w-50\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"aria-selected:bg-muted hover:bg-muted/50 aria-selected:outline-none\",\n      },\n      size: {\n        default: \"text-sm px-2 py-1\",\n        sm: \"text-xs px-1.5 py-0.5\",\n        lg: \"text-base px-3 py-1.5\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n);\n\nconst copyButtonVariants = cva(\n  \"relative size-4 text-muted-foreground absolute top-1/2 -translate-y-1/2 left-1/2 -translate-x-1/2 transition duration-300\",\n  {\n    variants: {\n      state: {\n        idle: \"opacity-100 scale-100\",\n        copied: \"opacity-0 scale-50\",\n      },\n    },\n    defaultVariants: {\n      state: \"idle\",\n    },\n  }\n);\n\n// Types\ntype CodeContextType = {\n  currentValue: string;\n  setCurrentValue: (value: string) => void;\n  codeMap: Map<string, string>;\n  registerCode: (value: string, code: string) => void;\n  groups: string[];\n  registerGroup: (group: string) => void;\n  currentGroup?: string;\n  registerTab: (value: string, group?: string) => void;\n};\n\n// Contexts\nconst CodeContext = createContext<CodeContextType>({\n  currentValue: \"\",\n  setCurrentValue: () => {},\n  codeMap: new Map(),\n  registerCode: () => {},\n  groups: [],\n  registerGroup: () => {},\n  currentGroup: undefined,\n  registerTab: () => {},\n});\n\nconst CodeGroupContext = createContext({\n  activeGroups: [] as string[],\n  setActiveGroups: (() => {}) as Dispatch<React.SetStateAction<string[]>>,\n});\n\n// Provider\nfunction CodeProvider({\n  children,\n  defaultActiveGroups = [],\n}: {\n  children: ReactNode;\n  defaultActiveGroups?: string[];\n}) {\n  const [activeGroups, setActiveGroups] =\n    useState<string[]>(defaultActiveGroups);\n\n  useEffect(() => {\n    const groups = localStorage.getItem(\"code-block-groups\");\n    if (groups) {\n      try {\n        setActiveGroups(JSON.parse(groups));\n      } catch (error) {\n        console.error(error);\n      }\n    } else if (defaultActiveGroups.length > 0) {\n      // localStorageに値がない場合のみdefaultを使用\n      setActiveGroups(defaultActiveGroups);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // defaultActiveGroupsは初期値なので依存配列に含めない\n\n  useEffect(() => {\n    if (activeGroups.length > 0) {\n      localStorage.setItem(\"code-block-groups\", JSON.stringify(activeGroups));\n    } else {\n      localStorage.removeItem(\"code-block-groups\");\n    }\n  }, [activeGroups]);\n\n  const contextValue = React.useMemo(\n    () => ({\n      activeGroups,\n      setActiveGroups,\n    }),\n    [activeGroups]\n  );\n\n  return <CodeGroupContext value={contextValue}>{children}</CodeGroupContext>;\n}\n\n// Hooks\nconst useCodeGroup = () => use(CodeGroupContext);\nconst useCode = () => use(CodeContext);\n\n// Block Provider (Internal use only)\nfunction CodeInternalProvider({\n  children,\n  defaultValue,\n  groups: initialGroups = [],\n}: {\n  children: ReactNode;\n  defaultValue?: string;\n  groups?: string[];\n}) {\n  const [currentValue, setCurrentValue] = useState<string>(defaultValue || \"\");\n  const [codeMap, setCodeMap] = useState<Map<string, string>>(new Map());\n  const [groups] = useState<string[]>(initialGroups);\n  const [groupTabsMap, setGroupTabsMap] = useState<Map<string, string[]>>(\n    new Map()\n  );\n  const { activeGroups, setActiveGroups } = useCodeGroup();\n\n  const currentGroup = useMemo(() => {\n    return groups.find((group) => activeGroups.includes(group));\n  }, [groups, activeGroups]);\n\n  const registerCode = useCallback((value: string, code: string) => {\n    setCodeMap((prev) => {\n      const newMap = new Map(prev);\n      newMap.set(value, code);\n      return newMap;\n    });\n  }, []);\n\n  const registerTab = useCallback((value: string, group?: string) => {\n    if (group) {\n      setGroupTabsMap((prev) => {\n        const newMap = new Map(prev);\n        const tabs = newMap.get(group) || [];\n        if (!tabs.includes(value)) {\n          newMap.set(group, [...tabs, value]);\n        }\n        return newMap;\n      });\n    }\n  }, []);\n\n  // groups が設定されているときに、activeGroups にこのコンポーネントのグループが含まれていない場合、\n  // 最初のグループを自動選択\n  useEffect(() => {\n    if (groups.length > 0) {\n      const firstGroup = groups[0];\n      if (firstGroup) {\n        setActiveGroups((prev) => {\n          // すでにこのコンポーネントのグループが設定されているかチェック\n          const hasAnyGroupFromThis = groups.some((g) => prev.includes(g));\n          if (!hasAnyGroupFromThis) {\n            return [...prev, firstGroup];\n          }\n          return prev;\n        });\n      }\n    }\n  }, [groups, setActiveGroups]);\n\n  // currentGroup が変更されたときに、そのグループに属する最初のタブに自動的に切り替える\n  useEffect(() => {\n    if (currentGroup) {\n      const tabsInGroup = groupTabsMap.get(currentGroup);\n      if (tabsInGroup && tabsInGroup.length > 0) {\n        const firstTab = tabsInGroup[0];\n        if (firstTab && firstTab !== currentValue) {\n          setCurrentValue(firstTab);\n        }\n      }\n    }\n  }, [currentGroup, groupTabsMap, currentValue]);\n\n  const contextValue = React.useMemo<CodeContextType>(\n    () => ({\n      currentValue,\n      setCurrentValue,\n      codeMap,\n      registerCode,\n      groups,\n      registerGroup: () => {}, // 互換性のために空の関数を提供\n      currentGroup,\n      registerTab,\n    }),\n    [\n      currentValue,\n      setCurrentValue,\n      codeMap,\n      registerCode,\n      groups,\n      currentGroup,\n      registerTab,\n    ]\n  );\n\n  return (\n    <CodeContext value={contextValue}>\n      <Tabs value={currentValue} onValueChange={setCurrentValue}>\n        {children}\n      </Tabs>\n    </CodeContext>\n  );\n}\n\n// UI Components\nfunction Codes({\n  defaultValue,\n  groups,\n  className,\n  asChild = false,\n  children,\n  ...props\n}: {\n  defaultValue?: string;\n  groups?: string[];\n} & React.ComponentProps<\"figure\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"figure\";\n\n  return (\n    <CodeInternalProvider defaultValue={defaultValue} groups={groups}>\n      <Comp\n        data-code-block=\"card\"\n        data-slot=\"code-block-card\"\n        className={cn(\"border rounded-lg overflow-hidden\", className)}\n        {...props}\n      >\n        {children}\n      </Comp>\n    </CodeInternalProvider>\n  );\n}\n\nfunction CodeHeader({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"figcaption\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"figcaption\";\n\n  return (\n    <Comp\n      data-code-block=\"header\"\n      data-slot=\"code-block-header\"\n      className={cn(\n        \"flex gap-2 h-12 text-sm text-muted-foreground items-center px-2 border-b not-prose\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CodeList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsList>) {\n  return (\n    <TabsList\n      data-code-block=\"tabs-list\"\n      data-slot=\"code-block-tabs-list\"\n      className={cn(\"flex gap-1 overflow-auto\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CodeDisplay({\n  html,\n  className,\n  ...props\n}: { html: string } & React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-code-block=\"display\"\n      data-slot=\"code-block-display\"\n      className={cn(\n        \"not-prose\",\n        \"*:border-none *:focus-visible:outline-none *:p-0! *:m-0 text-sm\",\n        \"overflow-auto\",\n        \"[&_code]:py-3 [&_code]:flex [&_code]:flex-col [&_code]:w-fit\",\n        \"[&_.line]:px-4 [&_.line]:leading-relaxed [&_.line]:py-px\",\n        \"[&_.highlighted]:bg-muted\",\n        className\n      )}\n      dangerouslySetInnerHTML={{ __html: html }}\n      {...props}\n    />\n  );\n}\n\nfunction CodeTrigger({\n  value,\n  group,\n  variant = \"default\",\n  size = \"default\",\n  className,\n  children,\n  ...props\n}: {\n  value: string;\n  group?: string;\n  children?: ReactNode;\n} & VariantProps<typeof codeTriggerVariants> &\n  Omit<React.ComponentProps<typeof TabsTrigger>, \"value\"> & { value: string }) {\n  const { activeGroups } = useCodeGroup();\n  const { currentGroup, groups, registerTab } = useCode();\n\n  // タブとグループの対応関係を登録\n  useEffect(() => {\n    registerTab(value, group);\n  }, [value, group, registerTab]);\n\n  // グループフィルタリング\n  if (group && groups.length > 0) {\n    // groups が登録されている場合のみフィルタリング\n    if (!currentGroup || currentGroup !== group) {\n      return null;\n    }\n  }\n\n  return (\n    <TabsTrigger\n      data-code-block=\"title\"\n      data-slot=\"code-block-title\"\n      data-group={group}\n      value={value}\n      className={cn(\n        codeTriggerVariants({ variant, size }),\n        \"only:bg-transparent!\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </TabsTrigger>\n  );\n}\n\nfunction CodeContent({\n  value,\n  code,\n  className,\n  children,\n  ...props\n}: {\n  value: string;\n  code: string;\n  children?: ReactNode;\n} & Omit<React.ComponentProps<typeof TabsContent>, \"value\">) {\n  const { registerCode } = useCode();\n\n  // code を登録\n  useEffect(() => {\n    registerCode(value, code);\n  }, [value, code, registerCode]);\n\n  return (\n    <TabsContent\n      data-code-block=\"content\"\n      data-slot=\"code-block-content\"\n      value={value}\n      className={cn(className)}\n      {...props}\n    >\n      {children}\n    </TabsContent>\n  );\n}\n\nfunction CodeCopyButton({\n  className,\n  ...props\n}: Omit<React.ComponentProps<typeof Button>, \"onClick\">) {\n  const { currentValue, codeMap } = useCode();\n  const [isCopied, setIsCopied] = useState(false);\n\n  const handleCopy = useCallback(() => {\n    const code = codeMap.get(currentValue);\n    /**\n     * Removes shiki transformer notation lines from code.\n     * @link https://shiki.style/packages/transformers\n     */\n    const cleanCode = code?.replace(/\\s*\\/\\/\\s*\\[!.*$/gm, \"\");\n\n    if (!cleanCode) return;\n\n    navigator.clipboard.writeText(cleanCode);\n    setIsCopied(true);\n    setTimeout(() => {\n      setIsCopied(false);\n    }, 2000);\n  }, [currentValue, codeMap]);\n\n  return (\n    <Button\n      data-code-block=\"copy-button\"\n      data-slot=\"code-block-copy-button\"\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={handleCopy}\n      className={cn(\"relative\", className)}\n      {...props}\n    >\n      <Copy\n        className={cn(\n          copyButtonVariants({ state: isCopied ? \"copied\" : \"idle\" })\n        )}\n      />\n      <Check\n        className={cn(\n          copyButtonVariants({ state: isCopied ? \"idle\" : \"copied\" })\n        )}\n      />\n      <span className=\"sr-only\">Copy Code</span>\n    </Button>\n  );\n}\n\nfunction CodeGroupSelector({\n  children,\n  ...props\n}: {\n  children?: ReactNode;\n} & Omit<\n  React.ComponentProps<typeof Select>,\n  \"value\" | \"onValueChange\" | \"children\"\n>) {\n  const { setActiveGroups } = useCodeGroup();\n  const { currentGroup, groups } = useCode();\n\n  const handleValueChange = useCallback(\n    (value: string) => {\n      setActiveGroups((values) => {\n        const cleanItems = values.filter((v) => !groups.includes(v));\n        return [...cleanItems, value];\n      });\n    },\n    [groups, setActiveGroups]\n  );\n\n  return (\n    <Select value={currentGroup} onValueChange={handleValueChange} {...props}>\n      <SelectTrigger\n        data-code-block=\"group-selector-trigger\"\n        data-slot=\"code-block-group-selector-trigger\"\n        className=\"[&_span]:truncate [&_span]:max-w-20\"\n      >\n        <SelectValue />\n      </SelectTrigger>\n      <SelectContent\n        data-code-block=\"group-selector-content\"\n        data-slot=\"code-block-group-selector-content\"\n        className=\"max-w-40\"\n        align=\"end\"\n      >\n        {children}\n      </SelectContent>\n    </Select>\n  );\n}\n\nfunction CodeGroupOption({\n  value,\n  children,\n  className,\n  ...props\n}: {\n  value: string;\n  children?: ReactNode;\n} & React.ComponentProps<typeof SelectItem>) {\n  return (\n    <SelectItem\n      value={value}\n      className={cn(\"[&_span]:truncate\", className)}\n      {...props}\n    >\n      <span className=\"flex items-center gap-2\">{children}</span>\n    </SelectItem>\n  );\n}\n\nexport {\n  CodeProvider,\n  Codes,\n  CodeHeader,\n  CodeList,\n  CodeTrigger,\n  CodeContent,\n  CodeDisplay,\n  CodeCopyButton,\n  CodeGroupSelector,\n  CodeGroupOption,\n  useCode,\n  useCodeGroup,\n};\n",
      "type": "registry:block"
    }
  ]
}